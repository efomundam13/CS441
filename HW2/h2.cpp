/*
Name: Manny Fomundam
Date: February 15,2024
Professor: John Bonomo
*/

// 1. Assume we want to draw a line from point (8, 13) to (19, 17) using
// the Bresenham algorithm. Determine the pixels which would be painted.

//The pixels that would be painted using the Bresenham algorithm are:
//(8, 13), (9, 13), (10, 14), (11, 14), (12, 15), (13, 15), (14, 16), (15, 16), (16, 17), (17, 17), (18, 17), (19, 17).

// 2. Assume we want to draw a circle of radius 12 centered a point (5, 6) using the
// Mid-point Circle algorithm. Determine the pixels which would be painted.

//The pixels that would be painted using the Midpoint algorithm are:
//(5,18),(5,-6),(17,6),(-7,6),(6,18),(4,18),
//(6,-6),(4,-6),(17,7),(-7,7),(17,5),(-7,5),
//(7,18),(3,18),(7,-6),(3,-6),(17,8),(-7,8),
//(17,4),(-7,4),(7,17),(3,17),(7,-5),(3,-5),
//(16,8),(-6,8),(16,4),(-6,4),(8,17),(2,17),
//(8,-5),(2,-5),(16,9),(-6,9),(16,3),(-6,3),
//(8,16),(2,16),(8,-4),(2,-4),(15,9),(-5,9),
//(15,3),(-5,3),(9,16),(1,16),(9,-4),(1,-4),
//(15,10),(-5,10),(15,2),(-5,2),(9,15),(1,15),
//(9,-3),(1,-3),(14,10),(-4,10),(14,2),(-4,2),
//(10,15),(0,15),(10,-3),(0,-3),(13,11),(-3,11),
//(13,1),(-3,1),(10,14),(0,14),(10,-2),(0,-2),
//(12,11),(-2,11),(12,1),(-2,1),(10,13),(0,13),
//(10,-1),(0,-1),(11,11),(-1,11),(11,1),(-1,1),
//(10,12),(0,12),(10,0),(0,0)

// 3. Write a method drawLine(x1, y1, x2, y2, color) which uses an object of this class to
// scan convert and draw a line between any two points (x1, y1) and (x2, y2). Try to use as little
// division as possible

void drawLive(int x1, int y1, int x2, int y2, Color color) {
    ScanConverter sc;
    sc.endPoints(x1, y1, x2, y2);
    while (!sc.done()) {
        int x, y;
        sc.nextPixel(x, y);
        drawPixel(x, y, color)
    }
}

// 4. Suppose we want to fill in the following polygon
//      a. Show the edge list table generated by this polygon

//Edge List Table (ELT):
//Lower	  Upper    Lower   Slope
//  Y       Y        X    Inverse
//  0       0        4       0
//  0       4        0       -1
//  0       8       10      1/2
//  4       8        0      3/2
//  4       8       10       1
//  4      10       10      1/3
//  6       8        8      -1
//  6      10        8       1

//      b. Show what the active edge list looks just prior to pixels being colored.

//Active Edge List (AEL):
//Scanline y = 0:
//Lower	  Upper    Lower   Slope
//  Y       Y        X    Inverse
//  0       4        0       -1
//  0       8       10      1/2

//Scanline y = 4:
//Lower	  Upper    Lower   Slope
//  Y       Y        X    Inverse
//  0       8       10      1/2
//  4       8        0      3/2
//  4       8       10       1
//  4      10       10      1/3

//Scanline y = 6:
//Lower	  Upper    Lower   Slope
//  Y       Y        X    Inverse
//  0       8       10      1/2
//  4       8        0      3/2
//  4       8       10       1
//  4      10       10      1/3
//  6       8        8      -1
//  6      10        8       1

//Scanline y = 8:
//Lower	  Upper    Lower   Slope
//  Y       Y        X    Inverse
//  4      10       10      1/3
//  6      10        8       1

//Scanline y = 10:
//Lower	  Upper    Lower   Slope
//  Y       Y        X    Inverse

// 5.
//      a. Set up a midpoint algorithm, taking symmetry considerations into account to scan convert
//         any parabola of the form y = ax^2 + b with input values for parameters a, b, and the range for x.

#include <GL/glut.h>

void drawParabola(float a, float dx) {
    float x = 0;
    float y = a * x * x;
    float midPoint = a * (x + 0.5) * (x + 0.5) - (y + 1);

    glBegin(GL_POINTS);
    while (x <= dx) {
        if (midPoint <= 0) {
            midPoint += 2 * a * x + 3 * a + 2;
            y++;
        } else {
            midPoint += 2 * a * x + 2 * a + 1;
        }
        x++;
        glVertex2f(x, y);
    }
    glEnd();
}

//      b. Modify the lineDDA method on page 140 in the text to draw the parabola described above

void lineDDA(int x0, int y0, int xEnd, int yEnd) {
    float a = (float)(yEnd - y0) / ((xEnd - x0) * (xEnd - x0));
    float dx = xEnd - x0;
    float x = x0;
    float y = y0;
    float midPoint = a * (x + 0.5) * (x + 0.5) - (y + 1);

    setPixel(round(x), round(y));
    while (x <= dx) {
        if (midPoint <= 0) {
            midPoint += 2 * a * x + 3 * a + 2;
            y++;
        } else {
            midPoint += 2 * a * x + 2 * a + 1;
        }
        x++;
        setPixel(round(x), round(y));
    }
}
